# reactor-performance-test

## 하는 일

리액터 파이프라인을 사용하여, 아래의 순서대로 아이템을 변환함.

`StartItem -> Step1Item -> Step2Item -> FinalItem` 

1. `StartItem` 생성. 하나의 스레드로, 약 0.1ms의 지연을 두고, 100만건을 순차적으로 생성.
2. `StartItem -> Step1Item` 변환. 각 변환에 최대 1ms의 지연을 두고, 여러개(최대 성능을 보장할 만큼)의 스레드로, 순서 보장함.
3. `Step1Item -> Step2Item` 변환. 각 변환에 최대 5ms의 지연을 두고, 여러개(최대 성능을 보장할 만큼)의 스레드로, 순서 보장함.
4. `Step2Item -> FinalItem` 변환. 각 변환에 최대 10ms의 지연을 두고, 16라는 고정된 갯수의 스레드로, 순서 보장하지 않음.

## 방법 비교

여러 가지 방식으로 리액터 파이프라인을 구축해 봄. 결과는 아래와 같음.

### TopicProcessorPipeline

- 리액터에 있는 `TopicProcessor`를 이용한 구현.
- 구현이 쉽고 이해하기도 쉽다.
- 하지만 가장 느린 방식.
- 성능은 아래와 같음.

```
start tps: 2312.4444444444443, detail: 2418, 2410, 2370, 2273, 2365, 2326, 2388, 2340, 1922
step1 tps: 2310.8888888888887, detail: 2419, 2404, 2381, 2262, 2385, 2326, 2375, 2326, 1920
step2 tps: 2311.0, detail: 2420, 2403, 2373, 2273, 2370, 2341, 2376, 2326, 1917
pipeline_final_0 tps: 144.44444444444446, detail: 151, 150, 148, 143, 148, 145, 150, 146, 119
pipeline_final_1 tps: 144.55555555555554, detail: 152, 150, 148, 142, 148, 146, 147, 147, 121
pipeline_final_2 tps: 144.55555555555554, detail: 150, 152, 147, 143, 148, 146, 148, 146, 121
pipeline_final_3 tps: 144.55555555555554, detail: 152, 151, 146, 144, 148, 145, 150, 145, 120
pipeline_final_4 tps: 144.44444444444446, detail: 151, 151, 148, 142, 148, 145, 148, 148, 119
pipeline_final_5 tps: 144.44444444444446, detail: 151, 150, 148, 143, 147, 146, 148, 147, 120
pipeline_final_6 tps: 144.44444444444446, detail: 150, 149, 150, 143, 147, 146, 147, 148, 120
pipeline_final_7 tps: 144.44444444444446, detail: 151, 150, 148, 142, 148, 147, 148, 145, 121
pipeline_final_8 tps: 144.44444444444446, detail: 151, 150, 148, 143, 147, 147, 147, 146, 121
pipeline_final_9 tps: 144.44444444444446, detail: 151, 150, 147, 144, 147, 146, 148, 147, 120
pipeline_final_10 tps: 144.33333333333334, detail: 150, 152, 147, 143, 147, 146, 148, 145, 121
pipeline_final_11 tps: 144.44444444444446, detail: 151, 151, 148, 143, 147, 147, 147, 147, 119
pipeline_final_12 tps: 144.55555555555554, detail: 151, 151, 147, 144, 147, 146, 148, 147, 120
pipeline_final_13 tps: 144.33333333333334, detail: 151, 150, 147, 143, 148, 145, 150, 145, 120
pipeline_final_14 tps: 144.33333333333334, detail: 151, 150, 148, 142, 148, 145, 150, 146, 119
pipeline_final_15 tps: 144.55555555555554, detail: 152, 150, 148, 142, 148, 146, 148, 146, 121
```

### NonTopicProcessorPipeline

- `TopicProcessor`를 사용한 이유는 파이프라인을 16개로 fan out 하기 위함이었음.
- 이를 위한 방법 중의 하나가 `TopicProcessor`였는데 혹시 더 빠른 방법은 없을까 고민.
- 그래서 fan out 기능만을 위한 간단한 `Processor`를 직접 만듦.
- 조금 더 구현이 어렵고 이해하기 어려워짐.
- 하지만 성능이 많이 좋아짐. (아래 참고)

```
start tps: 9179.666666666666, detail: 9978, 8054, 10069, 9940, 10942, 9049, 10132, 8614, 5839
step1 tps: 6187.111111111111, detail: 6531, 6509, 6271, 6645, 5979, 5672, 6300, 6364, 5413
step2 tps: 6187.444444444444, detail: 6540, 6512, 6264, 6642, 5981, 5669, 6297, 6398, 5384
pipeline_final_0 tps: 386.55555555555554, detail: 410, 408, 391, 415, 372, 355, 395, 400, 333
pipeline_final_1 tps: 386.6666666666667, detail: 408, 409, 389, 417, 374, 354, 395, 399, 335
pipeline_final_2 tps: 386.77777777777777, detail: 410, 405, 390, 418, 374, 353, 395, 400, 336
pipeline_final_3 tps: 386.77777777777777, detail: 410, 407, 391, 415, 374, 354, 394, 401, 335
pipeline_final_4 tps: 387.0, detail: 412, 407, 389, 417, 375, 352, 396, 399, 336
pipeline_final_5 tps: 387.0, detail: 410, 407, 391, 416, 376, 352, 393, 402, 336
pipeline_final_6 tps: 386.8888888888889, detail: 411, 408, 389, 417, 373, 354, 394, 401, 335
pipeline_final_7 tps: 386.77777777777777, detail: 410, 407, 390, 417, 374, 355, 393, 401, 334
pipeline_final_8 tps: 386.8888888888889, detail: 409, 407, 394, 414, 373, 353, 396, 400, 336
pipeline_final_9 tps: 386.6666666666667, detail: 411, 405, 392, 415, 374, 355, 392, 401, 335
pipeline_final_10 tps: 386.77777777777777, detail: 410, 406, 391, 416, 375, 354, 392, 402, 335
pipeline_final_11 tps: 386.8888888888889, detail: 409, 409, 391, 416, 372, 355, 392, 403, 335
pipeline_final_12 tps: 386.55555555555554, detail: 407, 409, 390, 414, 376, 353, 394, 401, 335
pipeline_final_13 tps: 386.77777777777777, detail: 408, 409, 392, 415, 373, 355, 393, 402, 334
pipeline_final_14 tps: 387.1111111111111, detail: 410, 408, 390, 416, 373, 355, 393, 401, 338
pipeline_final_15 tps: 386.8888888888889, detail: 410, 408, 390, 417, 372, 354, 395, 401, 335
```

### NonFanOutPipeline

- fan out을 하려고 했던 이유가 몇 가지 있었는데,
- 혹시 fan out이 비용이 굉장히 큰 작업이라면 아예 다른 접근법을 시도해보려고 했음.
- 그래서 fan out 하지 않는 방식으로 간단히 테스트 해 봄.
- 구현도 쉽고 가독성도 좋아졌지만,
- 성능이 좋지는 않음. 따라서, fan out은 유효한 것으로 보임. (참고로, fan out은 성능 외에도 몇 가지 이점을 가져다 줌)

```
start tps: 11333.0, detail: 11245, 11087, 11597, 11410, 11241, 11315, 11541, 11483, 11078
step1 tps: 4969.222222222223, detail: 4119, 4819, 4980, 5039, 5545, 4877, 5215, 5338, 4791
step2 tps: 4969.222222222223, detail: 4118, 4823, 4979, 5030, 5559, 4872, 5211, 5344, 4787
final tps: 4969.444444444444, detail: 4114, 4823, 4973, 5038, 5555, 4876, 5203, 5353, 4790
```

### StepMinifiedNonTopicProcessorPipeline

- `NonTopicProcessorPipeline` 방식이 좋다고 생각했고,
- 그럼 이 방식을 좀 더 최적화 해보고자 몇 가지 시도를 함.
- 가장 쉽게는 `Step1Item` 변환과 `Step2Item` 변환 단계를 합침.
- `flatMapSequential`이 두 번 일어나면서 성능 저하가 일어날 가능성을 항상 가질 수 밖에 없다고 생각했기 때문.
- 그래서 그 가능성을 제거하고자 두 단계를 합침.
- 실제로, 약간의 성능 개선이 됨. (386 -> 444tps)

```
start tps: 11641.888888888889, detail: 11908, 11847, 11532, 11386, 11380, 11305, 11811, 11825, 11783
step1 tps: 7111.333333333333, detail: 7167, 7095, 7104, 7084, 7094, 7162, 7083, 7155, 7058
step2 tps: 7111.333333333333, detail: 7157, 7103, 7105, 7082, 7100, 7146, 7087, 7149, 7073
pipeline_final_0 tps: 444.44444444444446, detail: 446, 444, 444, 445, 443, 448, 443, 444, 443
pipeline_final_1 tps: 444.22222222222223, detail: 446, 445, 443, 443, 446, 445, 442, 445, 443
pipeline_final_2 tps: 444.6666666666667, detail: 447, 446, 445, 442, 443, 446, 443, 447, 443
pipeline_final_3 tps: 444.6666666666667, detail: 446, 445, 445, 444, 444, 446, 441, 448, 443
pipeline_final_4 tps: 444.3333333333333, detail: 447, 442, 447, 441, 446, 444, 444, 445, 443
pipeline_final_5 tps: 444.44444444444446, detail: 448, 442, 443, 444, 445, 446, 444, 446, 442
pipeline_final_6 tps: 444.22222222222223, detail: 445, 444, 447, 441, 446, 445, 443, 445, 442
pipeline_final_7 tps: 444.55555555555554, detail: 449, 443, 444, 443, 444, 445, 443, 450, 440
pipeline_final_8 tps: 444.44444444444446, detail: 448, 444, 444, 442, 446, 445, 443, 447, 441
pipeline_final_9 tps: 444.77777777777777, detail: 447, 446, 443, 443, 445, 445, 443, 449, 442
pipeline_final_10 tps: 444.3333333333333, detail: 448, 444, 443, 443, 445, 444, 445, 446, 441
pipeline_final_11 tps: 444.44444444444446, detail: 446, 445, 443, 443, 444, 445, 441, 450, 443
pipeline_final_12 tps: 444.44444444444446, detail: 447, 443, 444, 442, 446, 445, 444, 446, 443
pipeline_final_13 tps: 444.44444444444446, detail: 448, 441, 446, 442, 445, 447, 442, 447, 442
pipeline_final_14 tps: 444.55555555555554, detail: 447, 445, 444, 444, 444, 446, 443, 447, 441
pipeline_final_15 tps: 444.6666666666667, detail: 449, 442, 447, 440, 446, 445, 442, 447, 444
```

### EfficientStepMinifiedNonTopicProcessorPipeline

- `StepMinifiedNonTopicProcessorPipeline`을 좀 더 개선해 보고자 함.
- 이를 위해 불필요한 `sink#next` 호출을 제거함.
    - `sink#next`의 비용이 혹시 큰 것은 아닐까(백프레셔 처리 등의 이유로) 의심했기 때문.
    - 기존에는 fan out 파이프라인에 `sink#next`를 일단 호출하고 각자 관심 없는 아이템은 필터링 하는 방식이었는데, `sink#next` 호출 전에 필터링 하도록 변경.
- 하지만 기존 버전과 성능 상의 차이는 없었음.
- Efficient 접두사를 붙였지만, 결론적으로는 잘못된 네이밍.

```
start tps: 11045.333333333334, detail: 11644, 11738, 11656, 11219, 8352, 10627, 11414, 11484, 11274
step1 tps: 7054.555555555556, detail: 7074, 7133, 7155, 7035, 6692, 7145, 7077, 7111, 7069
step2 tps: 7054.666666666667, detail: 7067, 7146, 7154, 7046, 6675, 7153, 7079, 7111, 7061
pipeline_final_0 tps: 441.1111111111111, detail: 441, 447, 447, 442, 417, 446, 443, 444, 443
pipeline_final_1 tps: 440.8888888888889, detail: 442, 447, 448, 440, 418, 446, 441, 446, 440
pipeline_final_2 tps: 440.55555555555554, detail: 442, 444, 447, 442, 418, 446, 442, 445, 439
pipeline_final_3 tps: 440.77777777777777, detail: 441, 444, 449, 440, 417, 447, 442, 445, 442
pipeline_final_4 tps: 440.77777777777777, detail: 441, 447, 449, 439, 417, 446, 443, 443, 442
pipeline_final_5 tps: 441.0, detail: 443, 445, 448, 440, 417, 447, 443, 444, 442
pipeline_final_6 tps: 441.1111111111111, detail: 442, 448, 448, 440, 416, 447, 443, 444, 442
pipeline_final_7 tps: 441.22222222222223, detail: 442, 446, 448, 439, 419, 446, 442, 445, 444
pipeline_final_8 tps: 440.8888888888889, detail: 440, 449, 446, 442, 416, 449, 438, 445, 443
pipeline_final_9 tps: 441.22222222222223, detail: 444, 444, 450, 440, 417, 448, 441, 443, 444
pipeline_final_10 tps: 440.8888888888889, detail: 440, 448, 448, 441, 416, 448, 441, 443, 443
pipeline_final_11 tps: 440.6666666666667, detail: 440, 449, 448, 439, 417, 446, 444, 443, 440
pipeline_final_12 tps: 440.77777777777777, detail: 443, 445, 449, 439, 416, 447, 444, 443, 441
pipeline_final_13 tps: 440.77777777777777, detail: 439, 448, 447, 440, 418, 448, 440, 445, 442
pipeline_final_14 tps: 440.8888888888889, detail: 443, 447, 446, 442, 414, 448, 444, 444, 440
pipeline_final_15 tps: 440.55555555555554, detail: 442, 444, 448, 440, 418, 445, 443, 445, 440
```

### OrderingStepMinifiedNonTopicProcessorPipeline

- `StepMinifiedNonTopicProcessorPipeline`에 순서 제약을 두면 어떻게 달라질지 궁금했음.
- 그래서, fan out 단계까지는 순서 보장하는 형태로 변경.
- 성능이 달라지지는 않음. (오히려 약간 좋아짐)
- 성능 차이도 없으면서, 오히려 순서 보장을 해준다는 측면에서 가장 많이 쓰이는 방식이 되지 않을까 함.
- 테스트 결과 기록은 생략.
